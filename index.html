<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlgoFlow: Step-by-Step Learning</title>
    <style>
        /* --- 1. Trendy UI Setup --- */
        :root {
            --bg-dark: #0f172a;
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.1);
            --primary: #8b5cf6;
            --accent: #f43f5e;   /* Swap */
            --compare: #f59e0b;  /* Compare */
            --done: #10b981;     /* Sorted */
            --text-main: #f8fafc;
        }

        body {
            background-color: var(--bg-dark);
            background-image: radial-gradient(circle at 50% 50%, #1e293b 0%, #0f172a 100%);
            color: var(--text-main);
            font-family: 'Pretendard', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            margin-bottom: 0.5rem;
            font-weight: 800;
            background: linear-gradient(to right, #a78bfa, #2dd4bf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* --- 2. Control Panel --- */
        .controls {
            display: flex;
            gap: 1rem;
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            padding: 1rem 2rem;
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            margin-bottom: 3rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        button, select {
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) { background: rgba(255,255,255,0.2); transform: translateY(-2px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background: var(--primary); border: none; }
        .btn-primary:hover:not(:disabled) { background: #7c3aed; box-shadow: 0 0 15px var(--primary); }
        
        .btn-step { background: var(--compare); border: none; color: #1e293b; }
        .btn-step:hover:not(:disabled) { background: #fbbf24; }

        /* --- 3. Visualization Stage --- */
        .stage-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between blocks */
            min-height: 200px;
            padding: 2rem;
            width: 90%;
            max-width: 1000px;
        }

        /* --- 4. Number Blocks (Cards) --- */
        .block {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--glass-border);
            border-radius: 16px;
            font-size: 2rem;
            font-weight: bold;
            color: var(--text-main);
            transition: all 0.4s ease; /* Smooth transition */
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* States */
        .block.compare {
            background: rgba(245, 158, 11, 0.2);
            border-color: var(--compare);
            color: var(--compare);
            transform: scale(1.1);
            z-index: 10;
        }

        .block.swap {
            background: rgba(244, 63, 94, 0.2);
            border-color: var(--accent);
            color: var(--accent);
            transform: translateY(-20px) scale(1.1); /* Lift up effect */
            z-index: 10;
        }

        .block.sorted {
            background: rgba(16, 185, 129, 0.2);
            border-color: var(--done);
            color: var(--done);
        }

        .status-text {
            margin-top: 2rem;
            font-size: 1.2rem;
            color: #94a3b8;
            min-height: 1.5em;
        }

    </style>
</head>
<body>

    <header style="text-align:center;">
        <h1>Algorithm Studio</h1>
        <div id="msg" class="status-text">Select an algorithm to start</div>
    </header>

    <div class="stage-container" id="stage">
        </div>

    <div class="controls">
        <select id="algoSelect" onchange="reset()">
            <option value="bubble">Bubblesort</option>
            <option value="insertion">Insertion Sort</option>
            <option value="quick">Quick Sort</option>
        </select>
        
        <button onclick="reset()">ðŸ”„ Reset</button>
        <div style="width: 1px; background: rgba(255,255,255,0.2); margin: 0 10px;"></div>
        
        <button id="btnAuto" class="btn-primary" onclick="start('auto')">â–¶ Auto Play (Slow)</button>
        <button id="btnManual" class="btn-step" onclick="start('manual')">ðŸ¦¶ Step Mode</button>
        <button id="btnNext" onclick="nextStepTrigger()" disabled>Next âž¡</button>
    </div>

    <script>
        // --- Configuration ---
        const STAGE = document.getElementById('stage');
        const MSG = document.getElementById('msg');
        const ARRAY_SIZE = 8;
        let array = [];
        let blockElements = [];
        
        // --- State Management ---
        let isSorting = false;
        let isPaused = false;
        let resolveNextStep = null; // Promise resolver for manual stepping
        let currentSpeed = 1000; // 1 second delay for auto mode

        // --- Initialization ---
        function generateArray() {
            array = [];
            // Generate distinct numbers for better clarity
            while(array.length < ARRAY_SIZE){
                let num = Math.floor(Math.random() * 90) + 10;
                if(array.indexOf(num) === -1) array.push(num);
            }
        }

        function drawBlocks() {
            STAGE.innerHTML = '';
            blockElements = [];
            array.forEach(val => {
                const div = document.createElement('div');
                div.classList.add('block');
                div.innerText = val;
                STAGE.appendChild(div);
                blockElements.push(div);
            });
        }

        function reset() {
            if (isSorting) { location.reload(); return; } // Hard reset if running
            generateArray();
            drawBlocks();
            updateMsg("Ready to sort.");
            enableControls(true);
            document.getElementById('btnNext').disabled = true;
        }

        // --- Core Control Logic (The Brain) ---
        
        // This function halts the loop until condition is met
        async function sync() {
            if (!isSorting) return;

            if (isPaused) {
                // Manual Mode: Wait until user clicks "Next"
                updateMsg("Waiting for next step...");
                document.getElementById('btnNext').disabled = false;
                document.getElementById('btnNext').classList.add('btn-primary'); // Highlight
                
                await new Promise(resolve => { resolveNextStep = resolve; });
                
                document.getElementById('btnNext').disabled = true;
                document.getElementById('btnNext').classList.remove('btn-primary');
            } else {
                // Auto Mode: Just wait for timer
                await new Promise(resolve => setTimeout(resolve, currentSpeed));
            }
        }

        function nextStepTrigger() {
            if (resolveNextStep) {
                resolveNextStep();
                resolveNextStep = null;
            }
        }

        async function start(mode) {
            if (isSorting) return;
            isSorting = true;
            isPaused = (mode === 'manual');
            
            enableControls(false); // Disable start buttons
            
            const algo = document.getElementById('algoSelect').value;
            updateMsg(mode === 'auto' ? "Auto Mode: Running..." : "Manual Mode: Press Next");

            if (algo === 'bubble') await bubbleSort();
            else if (algo === 'insertion') await insertionSort();
            else if (algo === 'quick') await quickSort(0, array.length - 1);

            isSorting = false;
            updateMsg("Sorting Complete! ðŸŽ‰");
            enableControls(true);
        }

        function enableControls(enabled) {
            document.getElementById('btnAuto').disabled = !enabled;
            document.getElementById('btnManual').disabled = !enabled;
            document.getElementById('algoSelect').disabled = !enabled;
        }

        function updateMsg(text) {
            MSG.innerText = text;
        }

        // --- Visualization Helper ---
        function setClass(idx, className) {
            if(blockElements[idx]) {
                blockElements[idx].className = 'block'; // reset
                if(className) blockElements[idx].classList.add(className);
            }
        }

        function swapVisual(i, j) {
            // Swap values in DOM
            let temp = blockElements[i].innerText;
            blockElements[i].innerText = blockElements[j].innerText;
            blockElements[j].innerText = temp;
        }

        // --- Algorithms ---

        // 1. Bubble Sort
        async function bubbleSort() {
            for (let i = 0; i < ARRAY_SIZE; i++) {
                for (let j = 0; j < ARRAY_SIZE - i - 1; j++) {
                    // Compare
                    setClass(j, 'compare');
                    setClass(j + 1, 'compare');
                    updateMsg(`Comparing ${array[j]} and ${array[j+1]}`);
                    await sync();

                    if (array[j] > array[j + 1]) {
                        // Swap Logic
                        setClass(j, 'swap');
                        setClass(j + 1, 'swap');
                        updateMsg(`Swapping ${array[j]} > ${array[j+1]}`);
                        await sync(); // Visual pause for swap

                        let temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                        swapVisual(j, j+1);
                    }
                    // Reset
                    setClass(j, '');
                    setClass(j + 1, '');
                }
                setClass(ARRAY_SIZE - i - 1, 'sorted');
            }
             // Ensure all are marked sorted at end
             for(let k=0; k<ARRAY_SIZE; k++) setClass(k, 'sorted');
        }

        // 2. Insertion Sort
        async function insertionSort() {
            setClass(0, 'sorted'); // First element is implicitly sorted
            
            for (let i = 1; i < ARRAY_SIZE; i++) {
                let current = array[i];
                let j = i - 1;
                
                setClass(i, 'swap'); // Selected
                updateMsg(`Selected ${current} to insert`);
                await sync();

                while (j >= 0 && array[j] > current) {
                    setClass(j, 'compare');
                    setClass(j + 1, 'swap'); // Position being moved to
                    updateMsg(`${array[j]} > ${current}, shifting right`);
                    await sync();
                    
                    array[j + 1] = array[j];
                    swapVisual(j, j+1); // Technically shift visual
                    
                    setClass(j + 1, 'sorted'); // Part of sorted array
                    setClass(j, '');
                    j--;
                }
                array[j + 1] = current;
                // Update the value at the insertion point just in case visual drift
                blockElements[j+1].innerText = current; 
                
                // Color entire sorted section
                for(let k=0; k<=i; k++) setClass(k, 'sorted');
                await sync();
            }
        }

        // 3. Quick Sort
        async function quickSort(start, end) {
            if (start >= end) {
                if(start >= 0 && start < ARRAY_SIZE) setClass(start, 'sorted');
                return;
            }

            let pivotIndex = await partition(start, end);
            
            // Mark pivot as sorted specifically
            setClass(pivotIndex, 'sorted'); 
            
            await quickSort(start, pivotIndex - 1);
            await quickSort(pivotIndex + 1, end);
        }

        async function partition(start, end) {
            let pivotValue = array[end];
            let pivotIndex = start;
            
            setClass(end, 'swap'); // Pivot
            updateMsg(`Pivot chosen: ${pivotValue}`);
            await sync();

            for (let i = start; i < end; i++) {
                setClass(i, 'compare');
                updateMsg(`Checking if ${array[i]} < Pivot(${pivotValue})`);
                await sync();

                if (array[i] < pivotValue) {
                    updateMsg(`${array[i]} is smaller, swapping to left`);
                    setClass(i, 'swap');
                    setClass(pivotIndex, 'swap');
                    await sync();

                    [array[i], array[pivotIndex]] = [array[pivotIndex], array[i]];
                    swapVisual(i, pivotIndex);
                    
                    setClass(pivotIndex, ''); // Reset color
                    pivotIndex++;
                }
                setClass(i, '');
            }
            
            updateMsg(`Placing Pivot in correct position`);
            swapVisual(pivotIndex, end);
            [array[pivotIndex], array[end]] = [array[end], array[pivotIndex]];
            
            return pivotIndex;
        }

        // Run on load
        reset();

    </script>
</body>
</html>
